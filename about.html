<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Large Rhythm Collider - About</title>
  <link rel="stylesheet" href="style.css">
  <style>
    html {
      overflow-y: auto;
      height: 100%;
    }
    body {
      margin: 0;
      padding: 0 1.5rem 3rem;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #111;
      background: #fafafa;
      min-height: 100%;
      overflow-y: auto;
    }
    header {
      padding: 3rem 0 2rem;
      text-align: center;
    }
    main {
      max-width: 960px;
      margin: 0 auto;
      background: #fff;
      padding: 2.5rem 3rem;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
      border-radius: 14px;
    }
    h1, h2, h3, h4, h5 {
      font-weight: 600;
      line-height: 1.3;
      color: #111;
    }
    h1 {
      margin-bottom: 0.5rem;
      font-size: clamp(2.25rem, 3vw, 3rem);
    }
    h2 {
      margin-top: 3rem;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid #ececec;
      padding-bottom: 0.5rem;
    }
    ul, ol {
      padding-left: 1.5rem;
    }
    li + li {
      margin-top: 0.25rem;
    }
    a {
      color: #0b5fff;
      text-decoration: none;
    }
    a:hover,
    a:focus {
      text-decoration: underline;
    }
    figure {
      margin: 2rem auto;
      text-align: center;
    }
    figure img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.12);
    }
    .image-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1.5rem;
      margin: 2rem 0;
    }
    .image-row img {
      max-width: min(100%, 360px);
      height: auto;
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.12);
    }
    .checklist {
      list-style: none;
      padding-left: 0;
    }
    .checklist li {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .checklist input[type="checkbox"] {
      accent-color: #0b5fff;
    }
    @media (max-width: 720px) {
      main {
        padding: 2rem 1.5rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Large Rhythm Collider</h1>
    <p>Generative Applications of Polyrhythms</p>
  </header>
  <main>
    <section id="overview">
      <h2>Overview</h2>
      <p>You&apos;ve found the Large Rhythm Collider! This website houses a multifaceted apparatus designed for the analysis of Polyrhythms.</p>
      <figure>
        <img src="assets/mainpage1.png" alt="Large Rhythm Collider main interface">
      </figure>
      <p>The Large Rhythm Collider offers a suite of analytical and creative tools which parse the fine details of polyrhythmic structures and deploy this information as the source code for a range of audiovisual applications. This intersection of art and mathematics possesses intricate generative beauty.</p>
      <br>
      <p>If you&apos;ve never encountered polyrhythms before, there are lots of great resources online which explain the basics. The LRC transforms the simple properties of cyclic division into an esoteric trove of patterned syncopation and structure. I always wondered what sort of things would be unveiled by pushing against the boundaries of this mathematical space. Ideas born years ago as thought experiments and practice routines have led me down the rabbithole to the architecture of this program. I hope you&apos;ll enjoy this journey as much as I have!</p>
      <br>
      <p>On the main page, you&apos;ll find 5 draggable, expandable control modules: Rhythm Input, Rhythm Info, Visualizations, Playback, and Search Algorithms. These sections provide full control of the LRC&apos;s functionality.</p>
      <figure>
        <img src="assets/mainpage_divs.png" alt="LRC control modules">
      </figure>
      <p>The LRC is designed to analyze polyrhythms of up to 4 layers. These ratio layer combinations a:b:c:d are bound by a simple multiplicative logic which encodes the internal structure of each rhythm. The core algorithm, while detailed, is simple arithmetic. The limitation to 4 layers is both a drummer&apos;s analogy and a computational consideration to keep the internal architecture manageable.</p>
    </section>

    <section id="quick-start">
      <h2>Quick Start</h2>
      <h3>Technical Requirements</h3>
      <p>As a fully JavaScript / HTML / CSS based web app, basic functionality should run smoothly on most systems. However, the system is designed to investigate Large Rhythms, so just remember that big numbers = more processing power.</p>
      <h4>Browser Compatibility</h4>
      <ul>
        <li><strong>Required</strong>: Modern browser with Web Audio API support
          <ul>
            <li>Chrome 66+ (recommended for best performance)</li>
            <li>Firefox 60+</li>
            <li>Safari 14.1+</li>
            <li>Edge 79+</li>
          </ul>
        </li>
        <li><strong>Required</strong>: JavaScript ES6+ support</li>
        <li><strong>Recommended</strong>: Hardware acceleration enabled for smooth visualizations</li>
      </ul>
      <h4>System Requirements</h4>
      <ul>
        <li><strong>RAM</strong>: Minimum 4GB recommended for complex polyrhythm calculations</li>
        <li><strong>CPU</strong>: Multi-core processor recommended for real-time audio processing</li>
        <li><strong>Audio</strong>: Dedicated audio hardware preferred for low-latency playback</li>
        <li><strong>Display</strong>: Minimum 1024x768 for full interface visibility</li>
      </ul>
      <h4>Audio System Requirements</h4>
      <ul>
        <li><strong>Sample Rate</strong>: 44.1kHz or 48kHz (automatically detected)</li>
        <li><strong>Buffer Size</strong>: Adjustable via Web Audio API (128-1024 samples)</li>
        <li><strong>Latency</strong>: &lt;50ms for real-time parameter adjustment</li>
        <li><strong>Channels</strong>: Stereo output supported</li>
      </ul>
      <h3>Installation &amp; Launch</h3>
      <p>The LRC is available at <a href="https://www.largerhythmcollider.com">largerhythmcollider.com</a>.</p>
      <ol>
        <li>Download or clone the repository</li>
        <li><strong>Simply double-click <code>index.html</code></strong> to open in your default browser
          <ul>
            <li>Or right-click → &quot;Open with&quot; → choose your preferred browser</li>
          </ul>
        </li>
        <li>Allow audio permissions when prompted</li>
        <li>Start exploring polyrhythms!</li>
      </ol>
      <h3>First Run Checklist</h3>
      <ul class="checklist">
        <li><input type="checkbox" disabled> Audio context activated (click anywhere if needed)</li>
        <li><input type="checkbox" disabled> Web Audio API detected (check browser console for errors)</li>
        <li><input type="checkbox" disabled> Test basic rhythm input (try 3:2, 7:5:3:2 polyrhythm)</li>
        <li><input type="checkbox" disabled> Verify playback functionality</li>
        <li><input type="checkbox" disabled> Check export functionality (MIDI download)</li>
      </ul>
    </section>

    <section id="mathematical-foundation">
      <h2>Mathematical Foundation</h2>
      <p>The Large Rhythm Collider employs a simple, naturally emergent algorithm to describe the composite structure of any given polyrhythm, but the real novelty is in the subsequent serialization of this polyrhythmic DNA into musical tuning systems. The following explanation is detailed, but some background research regarding rhythmic subdivision and meter, polyrhythms, the harmonic series, tuning and temperaments, just intonation, and the general physics of sound will help everything click.</p>
      <h3>Core Concepts</h3>
      <p>Up to four frequency layers are defined a:b:c:d. To be a valid polyrhythm, the layers must be coprime as a set (share no common factors), and no layers may be direct factors of another. However, individual layer pairs or tuples may share common factors. For example, 8:7:6:5 is valid because while 8:6 share a common factor, the entire layer set is coprime thanks to the 7 and 5. 8:7:6:4, on the other hand, would be invalid: the 4 adds no new information to the rhythm as it is already described by the 8. Note also that a layer value of 1 merely represents the entire cycle undivided.</p>
      <p>The LRC still allows for layer values that do not meet these criteria, but Search Algorithms will only return valid results.</p>
      <p>The least common multiple of the layer frequency values is the Grid, which is the length of the total cycle for this polyrhythm. When we divide the Grid by each of the layers, we get the grid duration or grouping size of each of those layers&apos; pulses.</p>
      <figure>
        <img src="assets/metrics1.png" alt="Polyrhythm metrics diagram" style="width:80%;">
      </figure>
      <p>Note that &quot;polyrhythm&quot; and &quot;polymeter&quot; are shown to be two sides of the same coin. Polyrhythms (frequency layers) are described by stacks of differently sized meters (grouping sizes). This fundamentally relativistic relationship of two interdependent dimensions is what truly defines the deterministic, yet mysterious behavior of polyrhythmic systems.</p>
      <p>When we construct a flattened list of all multiples of grouping sizes (pulse durations) up to the Grid value, we get the attack positions of every note in the Composite Rhythm.</p>
      <figure>
        <img src="assets/compositerhythm.png" alt="Composite rhythm diagram">
      </figure>
      <p>By analyzing the pulse layers as one whole, we extract their synergy. If we take the difference between every position in the composite rhythm, we get the Spaces Plot-the unique series of durations encoded specifically by the interference pattern of the layer inputs. We also track which layers generate which values in the spaces plot. This sequence is always a palindrome, as a consequence of its cyclic, multiplicative construction.</p>
      <figure>
        <img src="assets/spacesplot.png" alt="Spaces plot illustration">
      </figure>
      <p>From here, we move to the core innovation of the Collider concept: serialization of the spaces plot into pitch information!</p>
      <h3>Scale Creation</h3>
      <p>Just as the generating layer values represent ratios of frequencies, the unique slices of time generated by their interference patterns can also be assessed by their relative size and speed relationships. If we think of each of these values as the length of a period of a sound wave relative to all others in the set, we extract a tuning system. This is the conceptual leap, grounded in the ratio logic of polyrhythmic and harmonic series behavior. Essentially, the polyrhythm&apos;s structure encodes various little segments of time, all measured in relation to one another on the underlying grid. If we use all of those little segments to define the literal sizes of sound wave periods, that group of sound waves will possess a scale of relative frequency relationships, described by ratios-just like the generating layers.</p>
      <table>
        <tr>
          <td>
            <p>Here&apos;s the simplest example-3:2. This rhythm has a grid of 6 and is comprised of three groups of 2 and two groups of 3. We have a composite rhythm 0, 2, 3, 4 (6) which gives the spaces plot 2, 1, 1, 2 (notice that we calculate the distance from 4 to 6, the beginning of the next cycle). Two unique values, 2 and 1. What ratio relationship does this give us?</p>
            <p>We have a sound wave with length 2, and a sound wave with length 1. It&apos;s easy to see that we&apos;ll have two ones for every two-the shorter sound wave has a frequency of 2/1 relative to the largest sound wave in the set. 2/1 is exactly equivalent to an octave. So our tuning system really just has one note, which is repeated an octave higher. Try inputting 3:2 and playing it back to hear what this sounds like when we apply the proper pitches to corresponding note sizes in the spaces plot.</p>
          </td>
          <td align="center" valign="bottom">
            <img src="assets/3over2.png" alt="3 over 2 example" width="240">
          </td>
        </tr>
      </table>
      <p>Notice that when we convert from size to pitch, an inverse thing happens-1/1 is 2 units long, 2/1 is 1 unit long. How does this work with a more complex rhythm?</p>
      <p>Let&apos;s try the first four primes-7:5:3:2.</p>
      <p>The LCM or Grid for these numbers is 210, with grouping sizes 30, 42, 70, and 105 respectively. Arranging the composite rhythm and finding the difference between each position gives us this spaces plot:</p>
      <p>30, 12, 18, 10, 14, 6, 15, 15, 6, 14, 10, 18, 12, 30 - notice we still have a palindrome. The unique values are 30, 18, 15, 14, 12, 10, and 6.</p>
      <p>Note that the largest value in the spaces plot set is always the first and last. It&apos;s the grouping size of the fastest layer: because this layer is the fastest, it is always the first to occur after the downbeat, and because it continues repeating with the same duration, no value in the plot can possibly be larger. As largest value, it defines the longest or slowest oscillation of a sound wave-meaning the lowest pitch. This value is our Fundamental: it becomes the numerator against which all other ratios are compared as an undertone. The Fundamental is always the quotient Grid / Layer A.</p>
      <p>The smaller the value is, the faster the wave and the higher the pitch. This is why the Fundamental or largest value becomes an undertone generator. Take 30 and 18. First we can cancel out the shared factor of 6, leaving 5 and 3. Now, we know there will be five threes for every three fives. That means the 3 (or 18), which is the higher of the two pitches, is tuned to 30/18 or 5/3 above the Fundamental. All other unique values will initiate the same undertone comparison, generating the full pitch set.</p>
      <p>The final principle we apply to scale creation is octave compression-displaying all values within one octave. For tone row playback, we preserve the proper octave for each value, but for legible display of the tuning system, we compress all values in between 1/1 and 2/1. Take the above 7:5:3:2 scale-with 30/12, for example, we would simply move this frequency down an octave by halving it, multiplying the denominator by two and thus giving us 30/24 which simplifies to 3/2. This also means that, while every unique value in the spaces plot defines a unique octaviated interval, direct doubles (like 12 and 6 in this example) will create the same pitch in the final scale after octave compression.</p>
      <p>Try 7:5:3:2 on the main page and you&apos;ll see a five-tone scale: 1/1, 15/14, 5/4, 3/2, and 5/3. Note that the octave 2/1 may or may not always be present in any spaces plot, but we never include it in the final scale.</p>
      <figure>
        <img src="assets/first4primes.png" alt="First four primes example" style="width:30%;">
      </figure>
      <h3>Tuning Systems</h3>
      <p>You&apos;ll notice that our scales are comprised of ratios with corresponding cents values. In microtonal music theory, ratio-based or harmonic-series-based tuning approaches fall under the umbrella of just intonation. &quot;Microtonal&quot; tuning refers to any system which formally includes pitches not available in standard 12-tone equal temperament (12TET), which divides the octave into twelve equal partitions. Cents measure pitch space as it relates to 12TET-1200 cents equals one octave, 100 cents equals one semitone. In contrast to goal-oriented tunings like 12TET or sophisticated just intonation systems, the Large Rhythm Collider&apos;s methodology is somewhat mechanical and brutal; nonetheless, the deterministic bounds of the essential rhythm math bear curious strengths thanks to the breadth of available inputs and their emergent generative behaviors.</p>
      <h3>Conclusion</h3>
      <p>The Spaces Plot conversion via relative waveform period is the core math of the Large Rhythm Collider serial concept. The opaque prime factor relationships between layer values, combined with the multi-step scale creation algorithm, create results with a degree of entropy that naturally implores the emergence of deeper analytical methods. I came to realize that the LRC tuning concept provides a detailed scaffolding to classify polyrhythms by their relative complexity by assessing the granularity of the information they possess.</p>
      <p>The kaleidoscopic inner worlds of polyrhythms are made mappable and musical through the core analysis and sonification algorithm. Frequency layers become pulse &quot;arpeggiators&quot; of their rhythms&apos; bespoke tuning systems, washing over one another in blurred counterpoint. The scale creation concept also opens doors for organization, classification, and implementation outside of the purely musical realm, as you&apos;ll see in some of the visualizations. The engine&apos;s larger purpose is to compile polyrhythmic data into a unique, natural procedural generation system with widespread potential for application.</p>
      <figure>
        <img src="assets/mainpage2.png" alt="Large Rhythm Collider visuals">
      </figure>
    </section>

    <section id="key-features">
      <h2>Key Features</h2>
      <h3>Usage</h3>
      <p>Numbers go in, patterns and music come out. Use up to four whole numbers in the Rhythm Input section to define a polyrhythm. Pressing Generate prepares the system with that rhythm. You can access metrics in Rhythm Info, search for specific rhythm results, try different visualizations, and play back audio synced to the rhythm&apos;s internal timing and tuning systems. The following sections include detailed descriptions of all features.</p>
      <h3>Core Functionality</h3>
      <ul>
        <li><strong>Polyrhythm input and processing (up to four layers)</strong>: enter up to four frequency layers and generate the full analysis.</li>
        <li><strong>Composite rhythm generation</strong>: automatically calculate all attack positions across all layers.</li>
        <li><strong>Spaces plot calculation</strong>: derive the palindromic duration sequence.</li>
        <li><strong>Automatic scale/tuning system derivation</strong>: produce just-intonation tuning systems from rhythm structure.</li>
        <li><strong>Interconsonance analysis</strong>: reveal familiar-sounding intervals within the generated scales.</li>
        <li><strong>Real-time audio playback</strong>: wavetable synthesis with full ADSR and filter control.</li>
        <li><strong>Five visualization modes</strong>: Linear Plot, Reflections, Centrifuge, Hinges, and Collider Battle.</li>
        <li><strong>Four rhythm-finding search algorithms</strong>: Layer, Grid, Fundamental, and Inverse PG searches.</li>
      </ul>
      <h3>Rhythm Info / Expanded Info View</h3>
      <figure>
        <img src="assets/eiv.png" alt="Expanded Info View preview">
      </figure>
      <p>The Rhythm Info panel displays the relevant metrics and ratio scale for any generated rhythm, as well as the Interconsonance Analyzer and export functionality. Double-clicking the panel opens an Expanded Info View with more detail.</p>
      <h4>Metrics</h4>
      <figure>
        <img src="assets/metrics2.png" alt="Rhythm metrics">
      </figure>
      <p>Rhythm Info displays the Layers, Grid, and Fundamental values for this rhythm-scale (recall that the Fundamental is the grouping size of Layer A), along with a few other metrics:</p>
      <ul>
        <li><strong>Range</strong>: quotient of the fastest over slowest layer.</li>
        <li><strong>Density</strong>: percentage, quotient of layer sum over grid.</li>
        <li><strong>P/G Ratio</strong>: percentage, quotient of layer sum over grouping sum.</li>
        <li><strong>Composite Length</strong>: unique positions in composite rhythm.</li>
        <li><strong>Layer Sum</strong>: sum of all layer frequency values, distinct from composite length due to nested ratios and the coincidence on the downbeat.</li>
      </ul>
      <p>Range describes the literal frequency range of the polyrhythm layers-rhythms with smaller range values are more tightly packed.</p>
      <p>Density percentage tells us &quot;how much of the grid is covered by the rhythm?&quot; Layer Sum is used instead of Composite Length to give credence to the full weight of all frequency layers. High-frequency nested ratios can cause higher density by adding frequency values while constraining growth of the overall LCM.</p>
      <p>P/G ratio is a subtler metric that weighs the overall sum of the frequency values against the sum of the grouping sizes which create them. The grouping sum will always be greater than the layer sum, and higher density rhythms tend to have a higher P/G ratio, but P/G generally declines as Grid values grow. Rhythms may also have a P/G value of 1-see the Inverse PG section in Search Algorithms.</p>
      <p>One special metric, Average Deviation, only applies to 12-tone rhythm scales. This metric relates our microtonal just-intonation scales to the dominant contemporary tuning system, 12-tone equal temperament (12TET), in which the octave is logarithmically partitioned into 12 equal semitones measured as 100 cent intervals. Average Deviation is calculated by determining the intervallic cents distance between each successive step in the scale and calculating the deviation from 100 cents. For example, a 79-cent interval has a deviation of 21 cents, while a 105.6-cent interval has a deviation of 5.6 cents. We take the average of all 12 deviation values to yield the final metric.</p>
      <p>If you still need more numbers you can expand the Spaces Plot or Composite Rhythm sections to view the actual sequential source code of the given rhythm.</p>
      <p>Expanded Info View shows the same metrics as Rhythm Info, but it also includes the grouping sizes for all layers and a section called Nested Ratios.</p>
      <h4>Nested Ratios</h4>
      <figure>
        <img src="assets/nestedratios.png" alt="Nested ratios visualization">
      </figure>
      <p>Valid polyrhythms must be coprime as a set and have no layers which are direct factors of another layer. When only two layers are present, they may not share any factors. However, for three and four layer rhythms, common factors amongst layer tuples are allowed and provide abundance of specific classes of results by constraining scale size growth despite grid growth thanks to nested resolution patterns within the larger cycle-nested ratios. Even a simple rhythm, like the page default 8:7:6:5, has a nested ratio of 4:3 occurring twice between layers 8:6 (A and C). That&apos;s why the Nested Ratios section for this rhythm shows 2x A:C 8:6 = 4:3.</p>
      <h4>Interconsonance</h4>
      <div class="image-row">
        <img src="assets/interconsonance.png" alt="Interconsonance analyzer" style="max-width:320px;">
        <img src="assets/intervalmatrix.png" alt="Interval matrix" style="max-width:320px;">
      </div>
      <p>The final analytical component of the Info panels is the Interconsonance Analyzer. Just like the Average Deviation concept, the ICA is a bridge to the familiar sounds of 12TET.</p>
      <p>While the Average Deviation metric calculates the intervallic distance for all sequential steps, the ICA calculates the full interval matrix of all available interval pairs in the set. The number of available unique pairs can grow very large, so this feature may break down for very large scales, but it can still comfortably handle scales with 100 pitches per octave. These intervals are then assessed for consonance, which in our system refers to intervals within a +/-15 cent window of a multiple of 100 cents. These intervals are relatively close to the familiar 12TET intervals most of us are used to. The analyzer then finds subsets of ratios within the rhythm which all share consonance and organizes them into Consonance Families.</p>
      <figure>
        <img src="assets/consonancefamily.png" alt="Consonance family diagram" style="width:60%;">
      </figure>
      <h4>Export</h4>
      <figure>
        <img src="assets/export.png" alt="Export options">
      </figure>
      <p>The export section allows the user to export a PDF with the Expanded Info View details for the generated rhythm. The user can also export MIDI and tuning file information, described in the Audio section.</p>
      <h3>Audio &amp; Export</h3>
      <p>The LRC has a detailed playback system for its tone rows, as well as all necessary export functionality to generate the tuning systems and individual layer MIDI for use in a DAW.</p>
      <h4>Main Controls</h4>
      <table>
        <tr>
          <td width="260" align="center" valign="top">
            <img src="assets/maincontrols.png" alt="Main controls panel" width="240">
          </td>
          <td>
            <p><strong>Controls</strong></p>
            <ul>
              <li>Set the interval in seconds for one full cycle.</li>
              <li>Set the tuning of the fundamental frequency (defaults to A 110 Hz).</li>
              <li>Master volume with limiter.</li>
            </ul>
            <p>The seconds value defines the length of the entire cycle-play ultrafast rhythms or stretch them out to long legato scales. Cycle Time accepts values between 0.1 and 6000 seconds.</p>
            <p>The Fundamental input accepts Hz values between 55 and 880 Hz. Harsh high frequencies are automatically culled from playback, which is why you may hear occasional gaps correspondent to very small spaces plot values.</p>
            <p>The Master Volume slider defaults to a safe -24 dB and has a final limiter, but still be cautious when playing raw sine waves at high volumes.</p>
          </td>
        </tr>
      </table>
      <h4>Layer Controls</h4>
      <table>
        <tr>
          <td width="260" align="center" valign="top">
            <img src="assets/layercontrols.png" alt="Layer controls panel" width="240">
          </td>
          <td>
            <p><strong>Controls</strong></p>
            <ul>
              <li>Select from sine, triangle, sawtooth, or square wave for each layer.</li>
              <li>Individual volume control plus solo and mute for all layers.</li>
              <li>Per-layer low-pass and high-pass filters.</li>
              <li>Per-layer ADSR envelopes.</li>
              <li>Global legato mode to ensure notes are held for their full value.</li>
            </ul>
            <p>The LRC offers extensive DAW-like control over individual layer audio. Layers can be soloed, muted, or have their volumes set individually. Basic waveform synthesis offers sine, triangle, square, and sawtooth waves, along with an individual ADSR envelope and simple hi/lo-pass filter for each layer.</p>
            <p>The ADSR knobs can be double-clicked to manually edit their values.</p>
            <p>Legato mode is a global control which toggles retrigger behavior: when legato mode is off, each new note in the spaces plot silences the previous note. In legato mode, notes on each layer are held out until that layer sounds again. This allows you to hear the harmonic tuning relationships within each system sustained at slower tempos.</p>
          </td>
        </tr>
      </table>
      <h4>Scale Selection</h4>
      <table>
        <tr>
          <td width="260" align="center" valign="top">
            <img src="assets/scaleselection.png" alt="Scale selection panel" width="240">
          </td>
          <td>
            <p><strong>Controls</strong></p>
            <ul>
              <li>Turn individual pitches on and off using the scale chart in the Playback panel.</li>
              <li>See corresponding lights toggle on or off in the Linear Plot.</li>
              <li>Select Interconsonance Families directly from the Playback panel.</li>
            </ul>
            <p>With Scale Selection you can select and deselect pitches in real time to create smaller subsets of the larger tuning system. Alongside the scale chart, you&apos;ll see the count for each ratio, which is the number of times it actually appears in the spaces plot.</p>
            <p>Toggling pitches in Scale Selection also toggles them on and off in the Linear Plot, helping you visualize what you add and subtract as you hear it.</p>
            <p>If Interconsonance has been run in the Rhythm Info panel, individual interconsonance families can also be automatically selected in Scale Selection.</p>
          </td>
        </tr>
      </table>
      <h4>MIDI Export by Layer</h4>
      <ul>
        <li>Export MIDI with proper tone row sequencing for each layer.</li>
        <li>Resize or repurpose the MIDI clips in your DAW.</li>
        <li>Pair with tuning files to preserve the true tuning information.</li>
      </ul>
      <p>Because of the intense level of subdivision inherent in the growth of Grid values, exporting and using accurate MIDI is challenging. When you export MIDI from the web app, you&apos;ll get large clips for each individual layer with each note in sequence according to that layer&apos;s portion of the tone row. If you wish to hear the layers with their true polyrhythmic relationships, you&apos;ll need to resize the clips to the same interval of time (say one to eight bars). Otherwise, the MIDI is yours to experiment with-as are the tuning systems.</p>
      <h4>.tun / .scl Tuning File Export</h4>
      <ul>
        <li>Microtonal tuning file export for .tun and .scl formats.</li>
      </ul>
      <p>Playback of microtonal tuning systems in the box requires a software synth that can read tuning files. The LRC has export options for two common tuning file formats, .tun and .scl. Scales exported with .tun have their root note at MIDI note 9 (A-1), while scales exported with .scl are rooted around C.</p>
      <p>If you need other formats, consider <a href="https://sevish.com/scaleworkshop">Sevish&apos;s Scale Workshop</a>.</p>
      <h3>Visualizations</h3>
      <p>The LRC offers five visualization types.</p>
      <h4>Linear Plot</h4>
      <ul>
        <li>Primary visualization graphs palindromic sequence of spaces plot values.</li>
        <li>Layers are denoted by toggleable colored lights.</li>
        <li>Lights illuminate in sync with playback.</li>
        <li>Connectors show individual layer sequence.</li>
      </ul>
      <p>The Linear Plot is the original visualization concept that led to exploring various applications for the polyrhythmic source data. Playing with the initial layer inputs can create a wide range of patterns, all bearing a Rorschach-esque horizontal symmetry due to their palindromic construction.</p>
      <p>All layer lights may be toggled off with the lightbulb switch. You can view individual layer sequences by selecting any of the ABCD layer toggles. You can also press the Chain button to connect the notes for each layer in sequence.</p>
      <p>The Linear Plot and its layer lights sync to playback. It also responds to Scale Selection from the Playback panel, hiding notes which have been turned off. This allows you to hew more minimal audiovisual designs from the larger rhythm structure.</p>
      <p>You can use the green arrow toggle in the bottom right-hand corner of the plot to flip the vertical axis. This allows for more intuitive visual sync with audible pitch information during playback; since smaller values correspond to higher pitches, the default view places these values lower on the y-axis, which can feel counterintuitive.</p>
      <h4>Reflections (popup)</h4>
      <ul>
        <li>Duplication and manipulation of inherent palindromic structure creates detailed symmetric patterns.</li>
        <li>Various controls allow for different levels of reflection and tessellation.</li>
        <li>Basic animation options.</li>
        <li>Export functionality for still images or animations.</li>
      </ul>
      <p>Reflections grew out of the observation that the inherent horizontal symmetry of the Linear Plots would create distinct mandala-like patterns if they were duplicated and reflected over one another with increasing axes of symmetry. The Reflections popup has five main sections: Reflections, Tessellation, Animation, Colors, and Export.</p>
      <h5>Reflections Controls</h5>
      <ul>
        <li><strong>Type Selector</strong> offers Overlay and Reflecting Pool. Overlay draws each subsequent reflection directly over the layers below it. Reflecting Pool draws the first reflection (level 2) above a horizon line drawn at the top of the original graph, creating a mirror or reflecting pool visual. Subsequent levels are overlaid as in Overlay.</li>
        <li><strong>Blend Mode</strong> offers Difference, which creates interesting color shifts during animation, or Screen, a simpler and less computationally expensive overlay.</li>
        <li><strong>Reflection Level</strong> allows up to four plot duplications, each reflected over new lines of symmetry (180, 90, 45 degrees).</li>
        <li><strong>Dot Size</strong> resizes dots.</li>
      </ul>
      <h5>Tessellation</h5>
      <p>Tessellation allows the user to create up to a 4x4 tessellated grid of the Reflections image.</p>
      <h5>Animation</h5>
      <ul>
        <li>Master time control sets animation speed.</li>
        <li>Rotate the image around the center to see the symmetric structure shifting and phasing.</li>
        <li>Translate the image in four directions, with or without simultaneous rotation.</li>
        <li>Background plot toggleable to view rotation or translation with no blending.</li>
      </ul>
      <h5>Colors</h5>
      <ul>
        <li>Set colors for main plot, background plot, and canvas background.</li>
        <li>Color picker includes HSB sliders, hex codes, or RGB values.</li>
      </ul>
      <h5>Export Visualization</h5>
      <ul>
        <li>Export square PNG images of Reflections plots to your chosen dimensions.</li>
        <li>Video export available (web encoding capacities are somewhat limited).</li>
        <li>Set dimension, frame rate, and cycle time for animation.</li>
        <li>Enable rotation, translation, or both.</li>
        <li>Smart algorithm assesses level of duplication to reduce frame render counts.</li>
        <li>Progress bar tracks render and encoding phases.</li>
      </ul>
      <p>Web encoding works best with simpler visualizations; complex plots with Difference blending may show quality reduction.</p>
      <h4>Centrifuge</h4>
      <ul>
        <li>Layers visualized by spinning wheels.</li>
        <li>Scale ratios displayed around perimeter.</li>
        <li>Laps sync with tone row playback.</li>
        <li>Perimeter ratios light up in sync.</li>
        <li>Inner segments illuminate as layers rotate.</li>
      </ul>
      <p>The Centrifuge visualization displays each layer as a spinning wheel. The radii of each layer correspond to the layer&apos;s grouping size, and their rotation speeds correspond to their frequencies. Individual segments illuminate in sync with playback as their notes ring out. The perimeter also displays the ratios in the current scale, illuminating in sync with playback.</p>
      <h4>Hinges</h4>
      <ul>
        <li>Physical simulation generating structure and vector information from the spaces plot.</li>
        <li>Spaces plot values form links in a chain.</li>
        <li>Controls for cycle speed and amplitude of layer vector forces.</li>
        <li>Toggleable layer forces display.</li>
        <li>User changes individual layer vector directions with arrow keys.</li>
        <li>Three modes with different animation approaches.</li>
        <li>Anchors mode allows for expansion behavior and deep control based on nested ratios.</li>
      </ul>
      <p>The Hinges visualization uses the internal rhythmic structure to generate a physical simulation. Each value in the spaces plot defines the length of a segment in a chain, linked end to end upon starting the animation and bound with an internal constraint system.</p>
      <p>The source layer for each node and the corresponding value in the spaces plot defines a direction and magnitude for a motion vector for each node. The user can set the direction for each layer individually by clicking each arrow and pressing an arrow key for a new direction. Three Hinges modes utilize this layer force progression:</p>
      <h5>Layer Progression</h5>
      <p>Layer Progression triggers the layer forces one by one according to the overall cycle time and amplitude multiplier. Set the cycle time very short with high amplitude to see the structure swim around wildly. You can also view the vector force matrix with the Layer Forces toggle.</p>
      <h5>Mirrors</h5>
      <p>Mirrors executes the layer forces in a mirrored pattern, moving in opposite directions from the central node. This aligns with the palindromic nature of the Hinges construction.</p>
      <h5>Anchors</h5>
      <p>Anchors offers more structural control. Lock certain nodes in the structure, either based on their generating layer or based on nested ratios calculated between the polyrhythm layers. Anchors also offers Expand functionality which inflates the hinge structure to its maximum extent.</p>
      <h5>Tension</h5>
      <p>While using any of the three modes, engage Tension to freeze layer progression and prompt each segment in the structure to seek a flat angle with its neighbors. This slows everything down and creates a twisting screensaver-like pattern.</p>
      <h4>Collider Battle (popup)</h4>
      <ul>
        <li>Multiple hinge rhythm structures battle it out.</li>
        <li>User generates up to four starting polyrhythms.</li>
        <li>Each rhythm is animated according to hinges vector animation principles.</li>
        <li>Rhythms dance and collide; node-to-segment collisions cause the defending player to lose that segment.</li>
        <li>Actual scale ratios sound out as segments are destroyed.</li>
        <li>Battle progresses until only one player remains.</li>
        <li>User can control cycle speed, force amplitude, line thickness, and audio volume.</li>
      </ul>
      <p>After developing Hinges the natural question was: what if these could fight? The Collider battle lets multiple hinge structures dance around the scene, their nodes and segments colliding. Players can create their own rhythm with a Linear Plot preview on the Player Creation screen. In battle, if an attacking node strikes a player&apos;s segment, that segment is destroyed and its corresponding value is removed from the spaces plot and the layer force progression for that rhythm. The segments also sound out according to their actual note in their rhythm&apos;s tone row. A player is eliminated when all of their segments have been destroyed-last player standing wins. Gravity eventually kicks in and pulls players towards the center. Master controls influence cycle speed, force amplitude, line thickness (for visibility of large rhythms), and audio volume.</p>
      <p>Due to the computational expense of force progression, collision detection, and structural reconnection for multiple large rhythms, the Collider battle has a much lower ceiling on complexity than, say, Linear Plot, but you can still generate dynamic battles.</p>
      <h3>Search &amp; Analysis</h3>
      <p>A large part of the impetus to develop an engine for the Large Rhythm Collider concept was to enable the discovery and classification of rhythms at a much faster rate than working by hand. The engine offers four types of search algorithms targeted at specific essential metrics, using global constraints of scale size, search time, and range to generate results.</p>
      <p>Pitches introduces the concept of sorting the rhythms by scale size. Searching for 12-tone scales is a particularly interesting &quot;goldilocks&quot; zone given the connection to 12TET, but various scale sizes produce different results worth exploring. You can omit the Pitches parameter to get rhythm results with any number of pitches per octave.</p>
      <p>Recall that Range is the quotient between fastest and slowest layer. This qualifier allows you to weed out high-range results should you choose.</p>
      <p>Because these searches brute force large numbers of combinations, the system uses a Max Search Time interval. Some searches can continue to yield new results more or less indefinitely. Because searches may need to be carried out over multiple intervals, results are allowed to accumulate until the search parameters are changed or the results are cleared.</p>
      <p>The spinner animation lets you know when a search is being performed. When results subsections are populated, you can sort the tables by any of the columns, except Action. Clicking Apply for any result automatically sends that rhythm through the main generation pipeline.</p>
      <p>The search section minimizes result clutter by weeding out entries with duplicate grid + fundamental + ratio sets to an already-found result, but you can still view these results in the web console logs.</p>
      <h4>Rhythm Layer Search</h4>
      <p>Find results based on a given value for one of the four layers. Searches with a Layer A value are always completable; searches with no upper range limit and a value for any layer slower than A might be indefinite.</p>
      <h4>Grid Search</h4>
      <p>Find rhythms with a specific grid value, according to global parameters. Always completable; some grids (like primes and numbers without many factors) may have no results.</p>
      <h4>Fundamental Search</h4>
      <p>Find rhythms meeting global parameters with a specific fundamental value (grouping size of Layer A). These searches are generally indefinite, as fundamentals can continue to propagate, reaching higher multiples in grid space and relying on nested ratios to constrain scale size.</p>
      <h4>Inverse PG Search</h4>
      <p>A unique search which finds a special class of polyrhythm: those whose pulse (or layer frequency) values are a direct inverse of their grouping sizes. Any two-layer rhythm (meeting proper coprime requirements) will meet this qualification-say 3:2, three groups of 2, two groups of 3. Not all three- and four-layer rhythms meet this criteria, but some do-take 85:51:45:27 for example. Its layer frequencies are 85, 51, 45, and 27 while the corresponding grouping sizes are 27, 45, 51, and 85 respectively. Remember the P/G Ratio metric? Inverse PG rhythms have equivalent layer and grouping sums, leading to a P/G ratio of exactly 1.</p>
      <h3>Key Features - Summary and Future Development</h3>
      <p>The five control modules offer a host of analytical and audiovisual tools and simulations all generated from the mathematical basis of polyrhythm. The engine also creates a coherent framework for grander organization, compilation, and adaptation of large groups of polyrhythms, utilizing the emergent hierarchical properties of the system&apos;s inherent metrics to build interconnected databases. Stay tuned for all of that. If the project sparks ideas, reach out at <a href="mailto:aqldrum@gmail.com">aqldrum@gmail.com</a>.</p>
    </section>

    <section id="technical-architecture">
      <h2>Technical Architecture</h2>
      <h3>Core Modules</h3>
      <ul>
        <li><strong>LRCModule</strong>: handles main rhythm generation pipeline: grid, composite rhythm, spaces plot, metrics and scale creation</li>
        <li><strong>LRCVisuals</strong>: manages the drawing loop and camera transforms for Linear Plot, Hinges, Centrifuge and companion canvases</li>
        <li><strong>ToneRowPlayback</strong>: Web Audio driver for the oscillator bank, ADSR envelopes, legato handling, and cycle-time sync</li>
        <li><strong>LRCSearch</strong>: wraps the rhythm layer / grid / fundamental / inverse-PG search algorithms (with resume logic and timeouts)</li>
        <li><strong>LRCHudController</strong>: syncs generated metrics into the draggable HUD panels</li>
      </ul>
      <h3>Physics / Collision System</h3>
      <ul>
        <li><strong>Hinges</strong>: introduces real-time animation and physical simulation based on rhythm metrics</li>
        <li><strong>Collider</strong>: orchestrates the &quot;battle&quot; mode: spins up the popup window, wires the canvas to the main visuals, maintains the camera/animation loop, and hands control off to the battle controller and UI helpers</li>
        <li><strong>ColliderUI</strong>: builds and manages the external battle UI (popup, stage transitions, creation screen), syncing user actions back to the battle controller and keeping the canvas sized and responsive</li>
        <li><strong>ColliderPlayer</strong>: data / physics model for a single combatant: stores the rhythm-derived hinge geometry, runs the Verlet updates, tracks HP/invulnerability, and exposes hooks for synchronization with the master clock</li>
        <li><strong>CollisionDetector</strong>: performs the geometry work: derives collision tolerances from segment lengths, checks node-segment and node-node overlaps, and produces rebound impulses for the controller to apply</li>
        <li><strong>BattleController</strong>: game-state brain: instantiates players, applies rhythm data, keeps the master clock / materialized positions, triggers collision resolution and audio cues, and adjudicates victory conditions</li>
      </ul>
    </section>

    <section id="limitations">
      <h2>Known Limitations</h2>
      <p>All systems run fairly smoothly, but computational expense increases as the rhythms get bigger. You can enter any values you like into the main input and expect normal rhythm metric generation and playback to work even with layer values in the 4 to low 5 digits; however, your machine may not be able to properly render, say, a Hinges structure with tens of thousands of individual nodes, or display a scale with hundreds of tones cleanly around the Centrifuge. Search Algorithms for large values may also take a long time to yield results. There may be room for improvement in the speed of the search algorithms generally.</p>
      <p>Web encoding for Reflections animations currently works best with simpler visualizations; complex plots with Difference blending may show quality reduction.</p>
      <p>Collider Battle can also be buggy when trying to simulate large rhythms; collision detection may break down when increasing Line Thickness to high levels. The battle simulation tends to work best with simpler layer inputs in the double digits and below.</p>
    </section>

    <section id="credits">
      <h2>Credits</h2>
      <p>Special thanks go to Matthew Duveneck, my professor who generously translated early LRC concepts into R code, allowing me to begin computer-assisted system research.</p>
      <p>I also thank my friend and musical colleague Jacob Shulman for great chats about mathematical context and development possibilities, along with audio experiments in SuperCollider.</p>
      <p>I extend my heartfelt gratitude to all the friends and family over the years who have allowed me to yap away about the LRC. Thank you for your support and curiosity, and for the chance to practice effective communication of the core concepts.</p>
      <p>I also must thank Anthropic and OpenAI for extensive use of Claude Code and Codex CLI, LLMs which were instrumental in translating these ideas into a real codebase - these tools allowed me to accomplish in a few months what would have likely taken years of strife!</p>
    </section>

    <section id="contributing">
      <h2>Contributing</h2>
      <p>I&apos;m a musician and came into this process a novice programmer; as such, this project is primarily the result of AI-assisted vibecoding. There may be a number of blind spots or possibilities for improvement especially given the breadth of features and interconnected system architecture. Any feedback or new ideas from wiser parties is greatly appreciated!</p>
    </section>

    <section id="license">
      <h2>License</h2>
      <p>[Your chosen license]</p>
    </section>
  </main>
</body>
</html>
